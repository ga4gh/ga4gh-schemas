@namespace("org.ga4gh.models")
protocol Variants {

import idl "common.avdl";
import idl "references.avdl";

/*
We show how to provide information about samples.  The core idea is to provide
Calls which each contain information about the presence or absence of a set of
`Allele`s (as a group) in a `CallSet` (which can be a chromosome or a sample).
Loosely, the variant sets correspond to rows in a VCF and the callsets to a
column, but there are some key differences.

First, we provide information about alleles that may or may not exist in a call
set, and not sites at which a call set chooses between available alleles, since
we are using the "unary" or "allelic" variant model, in which we describe
variation with single alleles that may or may not be present in some copy
number. We can determine from the graph whether two alleles or sets of alleles
are incompatible in the same haplotype and hence "allelic" in the standard usage
of the term.  Note that this is a pairwise relation, not transitive. This avoids
the problems when merging sites in VCF. Our merge semantics are simple: only
merge identical variant sets. Identity can be checked by name when sharing a
global name and definition space, or recursively by how the alleles are
constructed from global objects when scope is local.

Second, we represent phase information by separate haplotype callSets, rather
than using some sort of | or / notation or equivalent in the calls of a genotype
callSet. So genotype callSets just contain allele counts (copy number) or
dosages. Because we support sparse callSets, which we hope can be lightweight,
each piece of partial haplotype phasing (as for example supported by phase sets
in VCF) will be a separate haplotype CallSet on the same sample. Since phasing
onto haplotypes can still be ambiguous in the case of complex duplications and
transpositions, we also provide a notion of Scaffolds which are ordered,
oriented, gapped lists of `Allele`s that are asserted to appear on the same
molecule.
*/

/**
This metadata represents VCF header information.
*/
record VariantSetMetadata {
  /** The top-level key. */
  string key;

  /** The value field for simple metadata. */
  string value;

  /**
  User-provided ID field, not enforced by this API.
  Two or more pieces of structured metadata with identical
  id and key fields are considered equivalent.
  */
  string id;

  /** The type of data. */
  string type;

  /**
  The number of values that can be included in a field described by this
  metadata.
  */
  string number;

  /** A textual description of this metadata. */
  string description;

  /** Remaining structured metadata key-value pairs. */
  map<array<string>> info = {};
}

/**
`Allele`s belong to `VariantSet`s. A `CallSet` has calls in a `VariantSet`.
Some novel `Reference`s can belong to `VariantSet`s (while other belong to
`ReferenceSet`s). A `VariantSet` belongs to a `Dataset`.
The variant set is equivalent to a VCF file.
*/
record VariantSet {
  /** The variant set ID. */
  string id;

  /** The ID of the dataset this variant set belongs to. */
  string datasetId;

  /**
  The reference set the variants in this variant set are using.
  */
  string referenceSetId;

  /**
  The metadata associated with this variant set. This is equivalent to
  the VCF header information not already presented in first class fields.
  */
  array<VariantSetMetadata> metadata = [];
}

/**
Some CallSets reflect genotype calls, while others reflect linked haplotype
calls.
*/
enum CallSetType {
  GENOTYPE,
  HAPLOTYPE
}

/**
A `CallSet` is a collection of variant calls for a particular sample.
It belongs to a `VariantSet`. This is equivalent to one column in VCF.
*/
record CallSet {

  /** The call set ID. */
  string id;

  /** The call set name. */
  union { null, string } name = null;

  /** The sample this call set's data was generated from. */
  union { null, string } sampleId;

  /**
  A `CallSet` must be either a genotype or a haplotype. This field specifies
  which. A HAPLOTYPE-type `CallSet` is just a bag of `Call`s on the same piece
  of DNA; there may be more than one way to traverse the graph as a single
  haplotype.
  */
  CallSetType callsetType;

  // For diploid genotypes the copy number of a set of `Allele`s in a `Call` will
  // typically be 0, 1 or 2; for haplotypes it will be 0 or 1

  /** The IDs of the variant sets this call set has calls in. */
  array<string> variantSetIds = [];

  /** The date this call set was created in milliseconds from the epoch. */
  union { null, long } created = null;

  /**
  The time at which this call set was last updated in
  milliseconds from the epoch.
  */
  union { null, long } updated = null;

  /**
  A map of additional call set information.
  */
  map<array<string>> info = {};
}

/**
A `Call` represents the determination of genotype with respect to a
particular `Allele`. It may include associated information such as quality
and phasing. For example, a call might assign a probability of 0.32 to
the occurrence of a SNP named rs1234 in a call set with the name NA12345.
*/
record Call {

  /**
  The ID of the call set this variant call belongs to.
  */
  union { null, string } callSetId;

  /**
  The name of the call set this variant call belongs to.
  */
  union { null, string } callSetName = null;

  /**
  The ID of the `Allele` that this Call reflects the presence of.
  */
  string alleleId;

  // HAPLOTYPE-type CallSets double as phase sets, so we don't need phase sets.

  // We have various ways of specifying what the call actually is.
  // Not all of the following will be present, but at least one should be

  /**
  0 for not present in callSet, 1 for single copy, 2 for 2 copies etc.
  */
  union { null, int } copyNumber = null;

  /**
  Expected value of copyNumber.
  */
  union { null, float } dosage = null;

  /**
  Probability that copy number is k: 0..n
  */
  array<float> probability = [];

  /**
  Likelihood of data given copy number k.
  */
  array<float> likelihood = [];

  /**
  Number of reads supporting this allele (DP in VCF).
  */
  union { null, int } readCount = null;

  /**
  Potential other evidence for the call.
  */
  map<string> evidence = {};

  /**
  A map of additional allele call information.
  */
  map<array<string>> info = {};
}

/**
`Allele`s are the key component of the "allelic" model of variation: they are
single objects that are present in some copy number.

An `Allele` is a contigous piece of sequence that we will want to say is present
(in general at some copy number) or absent in a sample. Very often it will just
be a single segment covering the entirety of a novel `Reference`, but it is also
common for it to be a `Segment` of a `Reference` not overlapped by another
`Allele`'s `Segment`s, or in general to be any contiguous path through the
sequence graph of `Reference`s.

`Allele`s belong to `VariantSet`s.

Remember that `Path`s cannot follow adjacencies not represented in the
`Reference`s they use. If you want an `Allele` that spans a novel deletion, say,
you must include a new `Reference` in your `VariantSet` providing that
adjacency, which your `Allele` can then follow.
*/
record Allele {
  /**
  The ID of this `Allele`. If this `Allele` is one segment consisting of the
  entirety of a `Reference`, this is equal to the ID of that `Reference`.
  */
  string id;

  /** The ID of the variant set this allele belongs to. */
  string variantSetId;

  /**
  The time at which this `Allele` was last updated in
  milliseconds from the epoch.
  */
  union { null, long } updated = null;

  /**
  What is this `Allele` describing the presence or absence of?

  If it is a Path, this allele represents the presence or absence of the
  corresponding `Segment`s in that order. Note that a `Segment` in this `Path`
  that is 0-length represents the adjacency immediately before the named base.

  If it is an array of strings, this `Allele` represents the presence or absence
  of all the `Allele`s with those IDs, as a unit. Note that cycles are not
  allowed; an `Allele` cannot directly or indirectly reference itself.
  */
  union { Path, array<string> } contents;
}

/**
The `Call`s in a `CallSet` are not explicitly ordered and oriented. This
reflects typically the data we have about them. In many cases we can infer order
and orientation from the reference graph on which the `Allele`s are defined, for
example for a sequence of simple variants (SNPs, indels etc) along a reference.
But in the general case with multiple copies of `Allele`s and rearrangements
this is not the case. For when we do want to explicitly state the order and
orientation of `Allele`s we define an `AlleleScaffold` record.

TODO: This is still being worked out; it is not entirely clear how this sort of
phasing ought to interact with haplotype phasing.
*/
record AlleleScaffold {
  /**
  ID of this `AlleleScaffold`.
  */
  string id;

  /**
  ID of the `CallSet` which this `AlleleScaffold` is associated with.
  */
  string callSetId;

  /**
  ID of the `VariantSet` which this `AlleleScaffold` is associated with.
  */
  string variantSetId;

  /**
  Array of `Allele` IDs in the order they appear in the scaffold.
  */
  array<string> alleleIds;

  /**
  Orientation of each `Allele` (relative to the orientation in which it is
  defined.
  */
  array<ReferenceSide> alleleOrientations;

  /**
  Sizes of gaps between `Allele`s, array length is 1 less than number of
  `Allele`s.
  */
  array<int> gapSizes = [];
}

// `Reference`s as defined in references.avdl are also used to represent novel
// allele sequence here.

}
